/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 317:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_svg_baker_runtime_browser_symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(780);
/* harmony import */ var _node_modules_svg_baker_runtime_browser_symbol_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_svg_baker_runtime_browser_symbol_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_svg_sprite_loader_runtime_browser_sprite_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(979);
/* harmony import */ var _node_modules_svg_sprite_loader_runtime_browser_sprite_build_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_svg_sprite_loader_runtime_browser_sprite_build_js__WEBPACK_IMPORTED_MODULE_1__);


var symbol = new (_node_modules_svg_baker_runtime_browser_symbol_js__WEBPACK_IMPORTED_MODULE_0___default())({
  "id": "icon-sample",
  "use": "icon-sample-usage",
  "viewBox": "0 0 32 32",
  "content": "<symbol xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 32 32\" id=\"icon-sample\"><path d=\"M4.637 24.096q-.576 0-.972-.216c-.396-.216-.492-.338-.684-.584l.504-.432q.233.297.524.456t.676.16q.4 0 .608-.164c.208-.164.207-.26.207-.453a.55.55 0 0 0-.14-.384q-.14-.151-.524-.208l-.352-.056a2.7 2.7 0 0 1-.544-.128 1.4 1.4 0 0 1-.424-.232q-.176-.144-.276-.352c-.1-.208-.1-.304-.1-.496q0-.304.112-.54t.312-.392c.2-.156.292-.183.476-.236q.276-.08.604-.08.528 0 .88.176c.352.176.44.28.616.488l-.472.448q-.153-.2-.412-.348c-.259-.148-.385-.148-.636-.148q-.384 0-.572.16a.53.53 0 0 0-.188.424q0 .28.18.408t.54.184l.352.056q.688.104.988.4t.3.776q0 .608-.424.96-.424.353-1.159.353M10.3 24q-.343 0-.516-.192c-.173-.192-.185-.293-.212-.496h-.04q-.128.384-.44.584c-.312.2-.461.2-.76.2q-.648 0-1.008-.332c-.36-.332-.36-.524-.36-.908q0-.6.436-.916.436-.315 1.332-.316h.784v-.376q0-.416-.224-.64c-.224-.224-.381-.224-.696-.224q-.367 0-.612.164a1.35 1.35 0 0 0-.404.428l-.448-.408q.184-.336.556-.572c.372-.236.564-.236.948-.236q.776 0 1.2.372c.424.372.424.597.424 1.049v2.179h.464V24zm-1.8-.504q.44 0 .728-.2c.288-.2.288-.304.288-.512v-.64h-.791q-.513 0-.748.152a.49.49 0 0 0-.236.44v.16q0 .288.204.444.204.155.555.156m3.112.504v-4.144h.744v.672h.04q.136-.317.412-.542c.276-.225.415-.226.692-.226s.529.066.756.198q.34.199.5.634h.016q.112-.333.428-.583.315-.25.836-.25.624 0 .976.416t.352 1.176V24h-.744v-2.542q0-.53-.204-.794c-.204-.264-.348-.265-.636-.265q-.184 0-.348.048c-.164.048-.207.079-.292.14a.7.7 0 0 0-.204.232.7.7 0 0 0-.076.333V24h-.744v-2.542q0-1.059-.832-1.059-.176 0-.344.048t-.296.14a.6.6 0 0 0-.208.232.67.67 0 0 0-.08.333V24zm7.016-4.145h.744v.672h.032q.144-.38.452-.574t.74-.194q.392 0 .7.148.308.149.524.432t.328.684c.112.4.112.568.112.904q0 .504-.112.904c-.112.4-.184.495-.328.684s-.319.333-.524.432a1.6 1.6 0 0 1-.7.148q-.432 0-.74-.194c-.308-.194-.356-.321-.452-.574h-.032V25.6h-.744zm1.752 3.601q.504 0 .796-.322.291-.322.292-.853v-.708q0-.53-.292-.853-.292-.321-.796-.322-.209 0-.392.057a1 1 0 0 0-.32.161q-.136.105-.216.241c-.08.136-.08.193-.08.306v1.528q0 .17.08.306c.08.136.125.172.216.241q.136.105.32.161t.392.057m3.704.544q-.385 0-.58-.208-.196-.209-.196-.552v-5.16h.744v5.28h.592V24zm3.033.096q-.432 0-.78-.156c-.348-.156-.429-.249-.592-.436s-.288-.413-.376-.68-.132-.565-.132-.896q0-.489.132-.892a1.9 1.9 0 0 1 .376-.684q.244-.28.592-.436c.348-.156.492-.156.78-.156s.545.052.772.156.417.246.572.427.272.396.352.646.12.518.12.805v.311h-2.92v.168q0 .52.304.852c.304.332.491.332.864.332q.392 0 .672-.176c.28-.176.336-.282.448-.496l.48.41q-.216.411-.648.656c-.432.245-.627.245-1.016.245m0-3.737q-.24 0-.444.087a1.06 1.06 0 0 0-.58.613q-.08.214-.08.469v.056h2.128v-.08q0-.516-.276-.831t-.748-.314M31 15.64h-2.64V7a.36.36 0 0 0-.105-.254l-6-6A.36.36 0 0 0 22 .64H4a.36.36 0 0 0-.36.36v14.64H1a.36.36 0 0 0-.36.36v11c0 .199.161.36.36.36h2.64V31c0 .199.161.36.36.36h24a.36.36 0 0 0 .36-.36v-3.64H31a.36.36 0 0 0 .36-.36V16a.36.36 0 0 0-.36-.36M22.36 1.87l4.771 4.771H22.36zm-18-.51h17.28V7c0 .199.161.36.36.36h5.64v8.28H4.36zm23.28 29.28H4.36v-3.28h23.28zm3-4H1.36V16.36h29.28z\" /><path d=\"M0 0h32v32H0z\" style=\"fill:none\" /></symbol>"
});
var result = _node_modules_svg_sprite_loader_runtime_browser_sprite_build_js__WEBPACK_IMPORTED_MODULE_1___default().add(symbol);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (symbol);

/***/ }),

/***/ 544:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "images/sample.png";

/***/ }),

/***/ 620:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var map = {
	"./icon-example.svg": 683,
	"./icon-sample.svg": 317,
	"./sample.png": 544
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 620;

/***/ }),

/***/ 683:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_svg_baker_runtime_browser_symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(780);
/* harmony import */ var _node_modules_svg_baker_runtime_browser_symbol_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_svg_baker_runtime_browser_symbol_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_svg_sprite_loader_runtime_browser_sprite_build_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(979);
/* harmony import */ var _node_modules_svg_sprite_loader_runtime_browser_sprite_build_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_svg_sprite_loader_runtime_browser_sprite_build_js__WEBPACK_IMPORTED_MODULE_1__);


var symbol = new (_node_modules_svg_baker_runtime_browser_symbol_js__WEBPACK_IMPORTED_MODULE_0___default())({
  "id": "icon-example",
  "use": "icon-example-usage",
  "viewBox": "0 0 1024 1024",
  "content": "<symbol xmlns=\"http://www.w3.org/2000/svg\" class=\"icon\" viewBox=\"0 0 1024 1024\" id=\"icon-example\"><path fill=\"#00BCD4\" d=\"M512 640c-70.4 0-128-57.6-128-128s57.6-128 128-128V106.667C288 106.667 106.667 288 106.667 512S288 917.333 512 917.333c93.867 0 181.333-32 251.733-87.466l-170.666-217.6C569.6 629.333 541.867 640 512 640\" /><path fill=\"#448AFF\" d=\"M640 512h277.333C917.333 288 736 106.667 512 106.667V384c70.4 0 128 57.6 128 128\" /><path fill=\"#3F51B5\" d=\"M917.333 512H640c0 40.533-19.2 76.8-49.067 100.267l170.667 217.6C857.6 755.2 917.333 640 917.333 512\" /></symbol>"
});
var result = _node_modules_svg_sprite_loader_runtime_browser_sprite_build_js__WEBPACK_IMPORTED_MODULE_1___default().add(symbol);
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (symbol);

/***/ }),

/***/ 780:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (global, factory) {
  ( false ? 0 : _typeof(exports)) === 'object' && "object" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
})(this, function () {
  'use strict';

  var SpriteSymbol = function SpriteSymbol(ref) {
    var id = ref.id;
    var viewBox = ref.viewBox;
    var content = ref.content;
    this.id = id;
    this.viewBox = viewBox;
    this.content = content;
  };

  /**
   * @return {string}
   */
  SpriteSymbol.prototype.stringify = function stringify() {
    return this.content;
  };

  /**
   * @return {string}
   */
  SpriteSymbol.prototype.toString = function toString() {
    return this.stringify();
  };
  SpriteSymbol.prototype.destroy = function destroy() {
    var this$1 = this;
    ['id', 'viewBox', 'content'].forEach(function (prop) {
      return delete this$1[prop];
    });
  };

  /**
   * @param {string} content
   * @return {Element}
   */
  var parse = function parse(content) {
    var hasImportNode = !!document.importNode;
    var doc = new DOMParser().parseFromString(content, 'image/svg+xml').documentElement;

    /**
     * Fix for browser which are throwing WrongDocumentError
     * if you insert an element which is not part of the document
     * @see http://stackoverflow.com/a/7986519/4624403
     */
    if (hasImportNode) {
      return document.importNode(doc, true);
    }
    return doc;
  };
  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};
  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }
  var deepmerge = createCommonjsModule(function (module, exports) {
    (function (root, factory) {
      if (false) {} else {
        module.exports = factory();
      }
    })(commonjsGlobal, function () {
      function isMergeableObject(val) {
        var nonNullObject = val && _typeof(val) === 'object';
        return nonNullObject && Object.prototype.toString.call(val) !== '[object RegExp]' && Object.prototype.toString.call(val) !== '[object Date]';
      }
      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }
      function cloneIfNecessary(value, optionsArgument) {
        var clone = optionsArgument && optionsArgument.clone === true;
        return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
      }
      function defaultArrayMerge(target, source, optionsArgument) {
        var destination = target.slice();
        source.forEach(function (e, i) {
          if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
          } else if (isMergeableObject(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument);
          } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument));
          }
        });
        return destination;
      }
      function mergeObject(target, source, optionsArgument) {
        var destination = {};
        if (isMergeableObject(target)) {
          Object.keys(target).forEach(function (key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
          });
        }
        Object.keys(source).forEach(function (key) {
          if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
          } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
          }
        });
        return destination;
      }
      function deepmerge(target, source, optionsArgument) {
        var array = Array.isArray(source);
        var options = optionsArgument || {
          arrayMerge: defaultArrayMerge
        };
        var arrayMerge = options.arrayMerge || defaultArrayMerge;
        if (array) {
          return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument);
        } else {
          return mergeObject(target, source, optionsArgument);
        }
      }
      deepmerge.all = function deepmergeAll(array, optionsArgument) {
        if (!Array.isArray(array) || array.length < 2) {
          throw new Error('first argument should be an array with at least two elements');
        }

        // we are sure there are at least 2 values, so it is safe to have no initial value
        return array.reduce(function (prev, next) {
          return deepmerge(prev, next, optionsArgument);
        });
      };
      return deepmerge;
    });
  });
  var namespaces_1 = createCommonjsModule(function (module, exports) {
    var namespaces = {
      svg: {
        name: 'xmlns',
        uri: 'http://www.w3.org/2000/svg'
      },
      xlink: {
        name: 'xmlns:xlink',
        uri: 'http://www.w3.org/1999/xlink'
      }
    };
    exports.default = namespaces;
    module.exports = exports.default;
  });

  /**
   * @param {Object} attrs
   * @return {string}
   */
  var objectToAttrsString = function objectToAttrsString(attrs) {
    return Object.keys(attrs).map(function (attr) {
      var value = attrs[attr].toString().replace(/"/g, '&quot;');
      return attr + "=\"" + value + "\"";
    }).join(' ');
  };
  var svg = namespaces_1.svg;
  var xlink = namespaces_1.xlink;
  var defaultAttrs = {};
  defaultAttrs[svg.name] = svg.uri;
  defaultAttrs[xlink.name] = xlink.uri;

  /**
   * @param {string} [content]
   * @param {Object} [attributes]
   * @return {string}
   */
  var wrapInSvgString = function wrapInSvgString(content, attributes) {
    if (content === void 0) content = '';
    var attrs = deepmerge(defaultAttrs, attributes || {});
    var attrsRendered = objectToAttrsString(attrs);
    return "<svg " + attrsRendered + ">" + content + "</svg>";
  };
  var BrowserSpriteSymbol = function (SpriteSymbol$$1) {
    function BrowserSpriteSymbol() {
      SpriteSymbol$$1.apply(this, arguments);
    }
    if (SpriteSymbol$$1) BrowserSpriteSymbol.__proto__ = SpriteSymbol$$1;
    BrowserSpriteSymbol.prototype = Object.create(SpriteSymbol$$1 && SpriteSymbol$$1.prototype);
    BrowserSpriteSymbol.prototype.constructor = BrowserSpriteSymbol;
    var prototypeAccessors = {
      isMounted: {}
    };
    prototypeAccessors.isMounted.get = function () {
      return !!this.node;
    };

    /**
     * @param {Element} node
     * @return {BrowserSpriteSymbol}
     */
    BrowserSpriteSymbol.createFromExistingNode = function createFromExistingNode(node) {
      return new BrowserSpriteSymbol({
        id: node.getAttribute('id'),
        viewBox: node.getAttribute('viewBox'),
        content: node.outerHTML
      });
    };
    BrowserSpriteSymbol.prototype.destroy = function destroy() {
      if (this.isMounted) {
        this.unmount();
      }
      SpriteSymbol$$1.prototype.destroy.call(this);
    };

    /**
     * @param {Element|string} target
     * @return {Element}
     */
    BrowserSpriteSymbol.prototype.mount = function mount(target) {
      if (this.isMounted) {
        return this.node;
      }
      var mountTarget = typeof target === 'string' ? document.querySelector(target) : target;
      var node = this.render();
      this.node = node;
      mountTarget.appendChild(node);
      return node;
    };

    /**
     * @return {Element}
     */
    BrowserSpriteSymbol.prototype.render = function render() {
      var content = this.stringify();
      return parse(wrapInSvgString(content)).childNodes[0];
    };
    BrowserSpriteSymbol.prototype.unmount = function unmount() {
      this.node.parentNode.removeChild(this.node);
    };
    Object.defineProperties(BrowserSpriteSymbol.prototype, prototypeAccessors);
    return BrowserSpriteSymbol;
  }(SpriteSymbol);
  return BrowserSpriteSymbol;
});

/***/ }),

/***/ 979:
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
(function (global, factory) {
  ( false ? 0 : _typeof(exports)) === 'object' && "object" !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
		__WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : 0;
})(this, function () {
  'use strict';

  var commonjsGlobal = typeof window !== 'undefined' ? window : typeof __webpack_require__.g !== 'undefined' ? __webpack_require__.g : typeof self !== 'undefined' ? self : {};
  function createCommonjsModule(fn, module) {
    return module = {
      exports: {}
    }, fn(module, module.exports), module.exports;
  }
  var deepmerge = createCommonjsModule(function (module, exports) {
    (function (root, factory) {
      if (false) {} else {
        module.exports = factory();
      }
    })(commonjsGlobal, function () {
      function isMergeableObject(val) {
        var nonNullObject = val && _typeof(val) === 'object';
        return nonNullObject && Object.prototype.toString.call(val) !== '[object RegExp]' && Object.prototype.toString.call(val) !== '[object Date]';
      }
      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }
      function cloneIfNecessary(value, optionsArgument) {
        var clone = optionsArgument && optionsArgument.clone === true;
        return clone && isMergeableObject(value) ? deepmerge(emptyTarget(value), value, optionsArgument) : value;
      }
      function defaultArrayMerge(target, source, optionsArgument) {
        var destination = target.slice();
        source.forEach(function (e, i) {
          if (typeof destination[i] === 'undefined') {
            destination[i] = cloneIfNecessary(e, optionsArgument);
          } else if (isMergeableObject(e)) {
            destination[i] = deepmerge(target[i], e, optionsArgument);
          } else if (target.indexOf(e) === -1) {
            destination.push(cloneIfNecessary(e, optionsArgument));
          }
        });
        return destination;
      }
      function mergeObject(target, source, optionsArgument) {
        var destination = {};
        if (isMergeableObject(target)) {
          Object.keys(target).forEach(function (key) {
            destination[key] = cloneIfNecessary(target[key], optionsArgument);
          });
        }
        Object.keys(source).forEach(function (key) {
          if (!isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneIfNecessary(source[key], optionsArgument);
          } else {
            destination[key] = deepmerge(target[key], source[key], optionsArgument);
          }
        });
        return destination;
      }
      function deepmerge(target, source, optionsArgument) {
        var array = Array.isArray(source);
        var options = optionsArgument || {
          arrayMerge: defaultArrayMerge
        };
        var arrayMerge = options.arrayMerge || defaultArrayMerge;
        if (array) {
          return Array.isArray(target) ? arrayMerge(target, source, optionsArgument) : cloneIfNecessary(source, optionsArgument);
        } else {
          return mergeObject(target, source, optionsArgument);
        }
      }
      deepmerge.all = function deepmergeAll(array, optionsArgument) {
        if (!Array.isArray(array) || array.length < 2) {
          throw new Error('first argument should be an array with at least two elements');
        }

        // we are sure there are at least 2 values, so it is safe to have no initial value
        return array.reduce(function (prev, next) {
          return deepmerge(prev, next, optionsArgument);
        });
      };
      return deepmerge;
    });
  });

  //      
  // An event handler can take an optional event argument
  // and should not return a value

  // An array of all currently registered event handlers for a type

  // A map of event types and their corresponding event handlers.

  /** Mitt: Tiny (~200b) functional event emitter / pubsub.
   *  @name mitt
   *  @returns {Mitt}
   */
  function mitt(all) {
    all = all || Object.create(null);
    return {
      /**
       * Register an event handler for the given type.
       *
       * @param  {String} type	Type of event to listen for, or `"*"` for all events
       * @param  {Function} handler Function to call in response to given event
       * @memberOf mitt
       */
      on: function on(type, handler) {
        (all[type] || (all[type] = [])).push(handler);
      },
      /**
       * Remove an event handler for the given type.
       *
       * @param  {String} type	Type of event to unregister `handler` from, or `"*"`
       * @param  {Function} handler Handler function to remove
       * @memberOf mitt
       */
      off: function off(type, handler) {
        if (all[type]) {
          all[type].splice(all[type].indexOf(handler) >>> 0, 1);
        }
      },
      /**
       * Invoke all handlers for the given type.
       * If present, `"*"` handlers are invoked after type-matched handlers.
       *
       * @param {String} type  The event type to invoke
       * @param {Any} [evt]  Any value (object is recommended and powerful), passed to each handler
       * @memberof mitt
       */
      emit: function emit(type, evt) {
        (all[type] || []).map(function (handler) {
          handler(evt);
        });
        (all['*'] || []).map(function (handler) {
          handler(type, evt);
        });
      }
    };
  }
  var namespaces_1 = createCommonjsModule(function (module, exports) {
    var namespaces = {
      svg: {
        name: 'xmlns',
        uri: 'http://www.w3.org/2000/svg'
      },
      xlink: {
        name: 'xmlns:xlink',
        uri: 'http://www.w3.org/1999/xlink'
      }
    };
    exports.default = namespaces;
    module.exports = exports.default;
  });

  /**
   * @param {Object} attrs
   * @return {string}
   */
  var objectToAttrsString = function objectToAttrsString(attrs) {
    return Object.keys(attrs).map(function (attr) {
      var value = attrs[attr].toString().replace(/"/g, '&quot;');
      return attr + "=\"" + value + "\"";
    }).join(' ');
  };
  var svg = namespaces_1.svg;
  var xlink = namespaces_1.xlink;
  var defaultAttrs = {};
  defaultAttrs[svg.name] = svg.uri;
  defaultAttrs[xlink.name] = xlink.uri;

  /**
   * @param {string} [content]
   * @param {Object} [attributes]
   * @return {string}
   */
  var wrapInSvgString = function wrapInSvgString(content, attributes) {
    if (content === void 0) content = '';
    var attrs = deepmerge(defaultAttrs, attributes || {});
    var attrsRendered = objectToAttrsString(attrs);
    return "<svg " + attrsRendered + ">" + content + "</svg>";
  };
  var svg$1 = namespaces_1.svg;
  var xlink$1 = namespaces_1.xlink;
  var defaultConfig = {
    attrs: (obj = {
      style: ['position: absolute', 'width: 0', 'height: 0'].join('; '),
      'aria-hidden': 'true'
    }, obj[svg$1.name] = svg$1.uri, obj[xlink$1.name] = xlink$1.uri, obj)
  };
  var obj;
  var Sprite = function Sprite(config) {
    this.config = deepmerge(defaultConfig, config || {});
    this.symbols = [];
  };

  /**
   * Add new symbol. If symbol with the same id exists it will be replaced.
   * @param {SpriteSymbol} symbol
   * @return {boolean} `true` - symbol was added, `false` - replaced
   */
  Sprite.prototype.add = function add(symbol) {
    var ref = this;
    var symbols = ref.symbols;
    var existing = this.find(symbol.id);
    if (existing) {
      symbols[symbols.indexOf(existing)] = symbol;
      return false;
    }
    symbols.push(symbol);
    return true;
  };

  /**
   * Remove symbol & destroy it
   * @param {string} id
   * @return {boolean} `true` - symbol was found & successfully destroyed, `false` - otherwise
   */
  Sprite.prototype.remove = function remove(id) {
    var ref = this;
    var symbols = ref.symbols;
    var symbol = this.find(id);
    if (symbol) {
      symbols.splice(symbols.indexOf(symbol), 1);
      symbol.destroy();
      return true;
    }
    return false;
  };

  /**
   * @param {string} id
   * @return {SpriteSymbol|null}
   */
  Sprite.prototype.find = function find(id) {
    return this.symbols.filter(function (s) {
      return s.id === id;
    })[0] || null;
  };

  /**
   * @param {string} id
   * @return {boolean}
   */
  Sprite.prototype.has = function has(id) {
    return this.find(id) !== null;
  };

  /**
   * @return {string}
   */
  Sprite.prototype.stringify = function stringify() {
    var ref = this.config;
    var attrs = ref.attrs;
    var stringifiedSymbols = this.symbols.map(function (s) {
      return s.stringify();
    }).join('');
    return wrapInSvgString(stringifiedSymbols, attrs);
  };

  /**
   * @return {string}
   */
  Sprite.prototype.toString = function toString() {
    return this.stringify();
  };
  Sprite.prototype.destroy = function destroy() {
    this.symbols.forEach(function (s) {
      return s.destroy();
    });
  };
  var SpriteSymbol = function SpriteSymbol(ref) {
    var id = ref.id;
    var viewBox = ref.viewBox;
    var content = ref.content;
    this.id = id;
    this.viewBox = viewBox;
    this.content = content;
  };

  /**
   * @return {string}
   */
  SpriteSymbol.prototype.stringify = function stringify() {
    return this.content;
  };

  /**
   * @return {string}
   */
  SpriteSymbol.prototype.toString = function toString() {
    return this.stringify();
  };
  SpriteSymbol.prototype.destroy = function destroy() {
    var this$1 = this;
    ['id', 'viewBox', 'content'].forEach(function (prop) {
      return delete this$1[prop];
    });
  };

  /**
   * @param {string} content
   * @return {Element}
   */
  var parse = function parse(content) {
    var hasImportNode = !!document.importNode;
    var doc = new DOMParser().parseFromString(content, 'image/svg+xml').documentElement;

    /**
     * Fix for browser which are throwing WrongDocumentError
     * if you insert an element which is not part of the document
     * @see http://stackoverflow.com/a/7986519/4624403
     */
    if (hasImportNode) {
      return document.importNode(doc, true);
    }
    return doc;
  };
  var BrowserSpriteSymbol = function (SpriteSymbol$$1) {
    function BrowserSpriteSymbol() {
      SpriteSymbol$$1.apply(this, arguments);
    }
    if (SpriteSymbol$$1) BrowserSpriteSymbol.__proto__ = SpriteSymbol$$1;
    BrowserSpriteSymbol.prototype = Object.create(SpriteSymbol$$1 && SpriteSymbol$$1.prototype);
    BrowserSpriteSymbol.prototype.constructor = BrowserSpriteSymbol;
    var prototypeAccessors = {
      isMounted: {}
    };
    prototypeAccessors.isMounted.get = function () {
      return !!this.node;
    };

    /**
     * @param {Element} node
     * @return {BrowserSpriteSymbol}
     */
    BrowserSpriteSymbol.createFromExistingNode = function createFromExistingNode(node) {
      return new BrowserSpriteSymbol({
        id: node.getAttribute('id'),
        viewBox: node.getAttribute('viewBox'),
        content: node.outerHTML
      });
    };
    BrowserSpriteSymbol.prototype.destroy = function destroy() {
      if (this.isMounted) {
        this.unmount();
      }
      SpriteSymbol$$1.prototype.destroy.call(this);
    };

    /**
     * @param {Element|string} target
     * @return {Element}
     */
    BrowserSpriteSymbol.prototype.mount = function mount(target) {
      if (this.isMounted) {
        return this.node;
      }
      var mountTarget = typeof target === 'string' ? document.querySelector(target) : target;
      var node = this.render();
      this.node = node;
      mountTarget.appendChild(node);
      return node;
    };

    /**
     * @return {Element}
     */
    BrowserSpriteSymbol.prototype.render = function render() {
      var content = this.stringify();
      return parse(wrapInSvgString(content)).childNodes[0];
    };
    BrowserSpriteSymbol.prototype.unmount = function unmount() {
      this.node.parentNode.removeChild(this.node);
    };
    Object.defineProperties(BrowserSpriteSymbol.prototype, prototypeAccessors);
    return BrowserSpriteSymbol;
  }(SpriteSymbol);
  var defaultConfig$1 = {
    /**
     * Should following options be automatically configured:
     * - `syncUrlsWithBaseTag`
     * - `locationChangeAngularEmitter`
     * - `moveGradientsOutsideSymbol`
     * @type {boolean}
     */
    autoConfigure: true,
    /**
     * Default mounting selector
     * @type {string}
     */
    mountTo: 'body',
    /**
     * Fix disappearing SVG elements when <base href> exists.
     * Executes when sprite mounted.
     * @see http://stackoverflow.com/a/18265336/796152
     * @see https://github.com/everdimension/angular-svg-base-fix
     * @see https://github.com/angular/angular.js/issues/8934#issuecomment-56568466
     * @type {boolean}
     */
    syncUrlsWithBaseTag: false,
    /**
     * Should sprite listen custom location change event
     * @type {boolean}
     */
    listenLocationChangeEvent: true,
    /**
     * Custom window event name which should be emitted to update sprite urls
     * @type {string}
     */
    locationChangeEvent: 'locationChange',
    /**
     * Emit location change event in Angular automatically
     * @type {boolean}
     */
    locationChangeAngularEmitter: false,
    /**
     * Selector to find symbols usages when updating sprite urls
     * @type {string}
     */
    usagesToUpdate: 'use[*|href]',
    /**
     * Fix Firefox bug when gradients and patterns don't work if they are within a symbol.
     * Executes when sprite is rendered, but not mounted.
     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=306674
     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=353575
     * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1235364
     * @type {boolean}
     */
    moveGradientsOutsideSymbol: false
  };

  /**
   * @param {*} arrayLike
   * @return {Array}
   */
  var arrayFrom = function arrayFrom(arrayLike) {
    return Array.prototype.slice.call(arrayLike, 0);
  };
  var browser = {
    isChrome: function isChrome() {
      return /chrome/i.test(navigator.userAgent);
    },
    isFirefox: function isFirefox() {
      return /firefox/i.test(navigator.userAgent);
    },
    // https://msdn.microsoft.com/en-us/library/ms537503(v=vs.85).aspx
    isIE: function isIE() {
      return /msie/i.test(navigator.userAgent) || /trident/i.test(navigator.userAgent);
    },
    isEdge: function isEdge() {
      return /edge/i.test(navigator.userAgent);
    }
  };

  /**
   * @param {string} name
   * @param {*} data
   */
  var dispatchEvent = function dispatchEvent(name, data) {
    var event = document.createEvent('CustomEvent');
    event.initCustomEvent(name, false, false, data);
    window.dispatchEvent(event);
  };

  /**
   * IE doesn't evaluate <style> tags in SVGs that are dynamically added to the page.
   * This trick will trigger IE to read and use any existing SVG <style> tags.
   * @see https://github.com/iconic/SVGInjector/issues/23
   * @see https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/10898469/
   *
   * @param {Element} node DOM Element to search <style> tags in
   * @return {Array<HTMLStyleElement>}
   */
  var evalStylesIEWorkaround = function evalStylesIEWorkaround(node) {
    var updatedNodes = [];
    arrayFrom(node.querySelectorAll('style')).forEach(function (style) {
      style.textContent += '';
      updatedNodes.push(style);
    });
    return updatedNodes;
  };

  /**
   * @param {string} [url] If not provided - current URL will be used
   * @return {string}
   */
  var getUrlWithoutFragment = function getUrlWithoutFragment(url) {
    return (url || window.location.href).split('#')[0];
  };

  /* global angular */
  /**
   * @param {string} eventName
   */
  var locationChangeAngularEmitter = function locationChangeAngularEmitter(eventName) {
    angular.module('ng').run(['$rootScope', function ($rootScope) {
      $rootScope.$on('$locationChangeSuccess', function (e, newUrl, oldUrl) {
        dispatchEvent(eventName, {
          oldUrl: oldUrl,
          newUrl: newUrl
        });
      });
    }]);
  };
  var defaultSelector = 'linearGradient, radialGradient, pattern, mask, clipPath';

  /**
   * @param {Element} svg
   * @param {string} [selector]
   * @return {Element}
   */
  var moveGradientsOutsideSymbol = function moveGradientsOutsideSymbol(svg, selector) {
    if (selector === void 0) selector = defaultSelector;
    arrayFrom(svg.querySelectorAll('symbol')).forEach(function (symbol) {
      arrayFrom(symbol.querySelectorAll(selector)).forEach(function (node) {
        symbol.parentNode.insertBefore(node, symbol);
      });
    });
    return svg;
  };

  /**
   * @param {NodeList} nodes
   * @param {Function} [matcher]
   * @return {Attr[]}
   */
  function selectAttributes(nodes, matcher) {
    var attrs = arrayFrom(nodes).reduce(function (acc, node) {
      if (!node.attributes) {
        return acc;
      }
      var arrayfied = arrayFrom(node.attributes);
      var matched = matcher ? arrayfied.filter(matcher) : arrayfied;
      return acc.concat(matched);
    }, []);
    return attrs;
  }

  /**
   * @param {NodeList|Node} nodes
   * @param {boolean} [clone=true]
   * @return {string}
   */

  var xLinkNS = namespaces_1.xlink.uri;
  var xLinkAttrName = 'xlink:href';

  // eslint-disable-next-line no-useless-escape
  var specialUrlCharsPattern = /[{}|\\\^\[\]`"<>]/g;
  function encoder(url) {
    return url.replace(specialUrlCharsPattern, function (match) {
      return "%" + match[0].charCodeAt(0).toString(16).toUpperCase();
    });
  }
  function escapeRegExp(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); // $& means the whole matched string
  }

  /**
   * @param {NodeList} nodes
   * @param {string} startsWith
   * @param {string} replaceWith
   * @return {NodeList}
   */
  function updateReferences(nodes, startsWith, replaceWith) {
    arrayFrom(nodes).forEach(function (node) {
      var href = node.getAttribute(xLinkAttrName);
      if (href && href.indexOf(startsWith) === 0) {
        var newUrl = href.replace(startsWith, replaceWith);
        node.setAttributeNS(xLinkNS, xLinkAttrName, newUrl);
      }
    });
    return nodes;
  }

  /**
   * List of SVG attributes to update url() target in them
   */
  var attList = ['clipPath', 'colorProfile', 'src', 'cursor', 'fill', 'filter', 'marker', 'markerStart', 'markerMid', 'markerEnd', 'mask', 'stroke', 'style'];
  var attSelector = attList.map(function (attr) {
    return "[" + attr + "]";
  }).join(',');

  /**
   * Update URLs in svg image (like `fill="url(...)"`) and update referencing elements
   * @param {Element} svg
   * @param {NodeList} references
   * @param {string|RegExp} startsWith
   * @param {string} replaceWith
   * @return {void}
   *
   * @example
   * const sprite = document.querySelector('svg.sprite');
   * const usages = document.querySelectorAll('use');
   * updateUrls(sprite, usages, '#', 'prefix#');
   */
  var updateUrls = function updateUrls(svg, references, startsWith, replaceWith) {
    var startsWithEncoded = encoder(startsWith);
    var replaceWithEncoded = encoder(replaceWith);
    var nodes = svg.querySelectorAll(attSelector);
    var attrs = selectAttributes(nodes, function (ref) {
      var localName = ref.localName;
      var value = ref.value;
      return attList.indexOf(localName) !== -1 && value.indexOf("url(" + startsWithEncoded) !== -1;
    });
    attrs.forEach(function (attr) {
      return attr.value = attr.value.replace(new RegExp(escapeRegExp(startsWithEncoded), 'g'), replaceWithEncoded);
    });
    updateReferences(references, startsWithEncoded, replaceWithEncoded);
  };

  /**
   * Internal emitter events
   * @enum
   * @private
   */
  var Events = {
    MOUNT: 'mount',
    SYMBOL_MOUNT: 'symbol_mount'
  };
  var BrowserSprite = function (Sprite$$1) {
    function BrowserSprite(cfg) {
      var this$1 = this;
      if (cfg === void 0) cfg = {};
      Sprite$$1.call(this, deepmerge(defaultConfig$1, cfg));
      var emitter = mitt();
      this._emitter = emitter;
      this.node = null;
      var ref = this;
      var config = ref.config;
      if (config.autoConfigure) {
        this._autoConfigure(cfg);
      }
      if (config.syncUrlsWithBaseTag) {
        var baseUrl = document.getElementsByTagName('base')[0].getAttribute('href');
        emitter.on(Events.MOUNT, function () {
          return this$1.updateUrls('#', baseUrl);
        });
      }
      var handleLocationChange = this._handleLocationChange.bind(this);
      this._handleLocationChange = handleLocationChange;

      // Provide way to update sprite urls externally via dispatching custom window event
      if (config.listenLocationChangeEvent) {
        window.addEventListener(config.locationChangeEvent, handleLocationChange);
      }

      // Emit location change event in Angular automatically
      if (config.locationChangeAngularEmitter) {
        locationChangeAngularEmitter(config.locationChangeEvent);
      }

      // After sprite mounted
      emitter.on(Events.MOUNT, function (spriteNode) {
        if (config.moveGradientsOutsideSymbol) {
          moveGradientsOutsideSymbol(spriteNode);
        }
      });

      // After symbol mounted into sprite
      emitter.on(Events.SYMBOL_MOUNT, function (symbolNode) {
        if (config.moveGradientsOutsideSymbol) {
          moveGradientsOutsideSymbol(symbolNode.parentNode);
        }
        if (browser.isIE() || browser.isEdge()) {
          evalStylesIEWorkaround(symbolNode);
        }
      });
    }
    if (Sprite$$1) BrowserSprite.__proto__ = Sprite$$1;
    BrowserSprite.prototype = Object.create(Sprite$$1 && Sprite$$1.prototype);
    BrowserSprite.prototype.constructor = BrowserSprite;
    var prototypeAccessors = {
      isMounted: {}
    };

    /**
     * @return {boolean}
     */
    prototypeAccessors.isMounted.get = function () {
      return !!this.node;
    };

    /**
     * Automatically configure following options
     * - `syncUrlsWithBaseTag`
     * - `locationChangeAngularEmitter`
     * - `moveGradientsOutsideSymbol`
     * @param {Object} cfg
     * @private
     */
    BrowserSprite.prototype._autoConfigure = function _autoConfigure(cfg) {
      var ref = this;
      var config = ref.config;
      if (typeof cfg.syncUrlsWithBaseTag === 'undefined') {
        config.syncUrlsWithBaseTag = typeof document.getElementsByTagName('base')[0] !== 'undefined';
      }
      if (typeof cfg.locationChangeAngularEmitter === 'undefined') {
        config.locationChangeAngularEmitter = typeof window.angular !== 'undefined';
      }
      if (typeof cfg.moveGradientsOutsideSymbol === 'undefined') {
        config.moveGradientsOutsideSymbol = browser.isFirefox();
      }
    };

    /**
     * @param {Event} event
     * @param {Object} event.detail
     * @param {string} event.detail.oldUrl
     * @param {string} event.detail.newUrl
     * @private
     */
    BrowserSprite.prototype._handleLocationChange = function _handleLocationChange(event) {
      var ref = event.detail;
      var oldUrl = ref.oldUrl;
      var newUrl = ref.newUrl;
      this.updateUrls(oldUrl, newUrl);
    };

    /**
     * Add new symbol. If symbol with the same id exists it will be replaced.
     * If sprite already mounted - `symbol.mount(sprite.node)` will be called.
     * @fires Events#SYMBOL_MOUNT
     * @param {BrowserSpriteSymbol} symbol
     * @return {boolean} `true` - symbol was added, `false` - replaced
     */
    BrowserSprite.prototype.add = function add(symbol) {
      var sprite = this;
      var isNewSymbol = Sprite$$1.prototype.add.call(this, symbol);
      if (this.isMounted && isNewSymbol) {
        symbol.mount(sprite.node);
        this._emitter.emit(Events.SYMBOL_MOUNT, symbol.node);
      }
      return isNewSymbol;
    };

    /**
     * Attach to existing DOM node
     * @param {string|Element} target
     * @return {Element|null} attached DOM Element. null if node to attach not found.
     */
    BrowserSprite.prototype.attach = function attach(target) {
      var this$1 = this;
      var sprite = this;
      if (sprite.isMounted) {
        return sprite.node;
      }

      /** @type Element */
      var node = typeof target === 'string' ? document.querySelector(target) : target;
      sprite.node = node;

      // Already added symbols needs to be mounted
      this.symbols.forEach(function (symbol) {
        symbol.mount(sprite.node);
        this$1._emitter.emit(Events.SYMBOL_MOUNT, symbol.node);
      });

      // Create symbols from existing DOM nodes, add and mount them
      arrayFrom(node.querySelectorAll('symbol')).forEach(function (symbolNode) {
        var symbol = BrowserSpriteSymbol.createFromExistingNode(symbolNode);
        symbol.node = symbolNode; // hack to prevent symbol mounting to sprite when adding
        sprite.add(symbol);
      });
      this._emitter.emit(Events.MOUNT, node);
      return node;
    };
    BrowserSprite.prototype.destroy = function destroy() {
      var ref = this;
      var config = ref.config;
      var symbols = ref.symbols;
      var _emitter = ref._emitter;
      symbols.forEach(function (s) {
        return s.destroy();
      });
      _emitter.off('*');
      window.removeEventListener(config.locationChangeEvent, this._handleLocationChange);
      if (this.isMounted) {
        this.unmount();
      }
    };

    /**
     * @fires Events#MOUNT
     * @param {string|Element} [target]
     * @param {boolean} [prepend=false]
     * @return {Element|null} rendered sprite node. null if mount node not found.
     */
    BrowserSprite.prototype.mount = function mount(target, prepend) {
      if (target === void 0) target = this.config.mountTo;
      if (prepend === void 0) prepend = false;
      var sprite = this;
      if (sprite.isMounted) {
        return sprite.node;
      }
      var mountNode = typeof target === 'string' ? document.querySelector(target) : target;
      var node = sprite.render();
      this.node = node;
      if (prepend && mountNode.childNodes[0]) {
        mountNode.insertBefore(node, mountNode.childNodes[0]);
      } else {
        mountNode.appendChild(node);
      }
      this._emitter.emit(Events.MOUNT, node);
      return node;
    };

    /**
     * @return {Element}
     */
    BrowserSprite.prototype.render = function render() {
      return parse(this.stringify());
    };

    /**
     * Detach sprite from the DOM
     */
    BrowserSprite.prototype.unmount = function unmount() {
      this.node.parentNode.removeChild(this.node);
    };

    /**
     * Update URLs in sprite and usage elements
     * @param {string} oldUrl
     * @param {string} newUrl
     * @return {boolean} `true` - URLs was updated, `false` - sprite is not mounted
     */
    BrowserSprite.prototype.updateUrls = function updateUrls$1(oldUrl, newUrl) {
      if (!this.isMounted) {
        return false;
      }
      var usages = document.querySelectorAll(this.config.usagesToUpdate);
      updateUrls(this.node, usages, getUrlWithoutFragment(oldUrl) + "#", getUrlWithoutFragment(newUrl) + "#");
      return true;
    };
    Object.defineProperties(BrowserSprite.prototype, prototypeAccessors);
    return BrowserSprite;
  }(Sprite);
  var ready$1 = createCommonjsModule(function (module) {
    /*!
      * domready (c) Dustin Diaz 2014 - License MIT
      */
    !function (name, definition) {
      {
        module.exports = definition();
      }
    }('domready', function () {
      var fns = [],
        _listener,
        doc = document,
        hack = doc.documentElement.doScroll,
        domContentLoaded = 'DOMContentLoaded',
        loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState);
      if (!loaded) {
        doc.addEventListener(domContentLoaded, _listener = function listener() {
          doc.removeEventListener(domContentLoaded, _listener);
          loaded = 1;
          while (_listener = fns.shift()) {
            _listener();
          }
        });
      }
      return function (fn) {
        loaded ? setTimeout(fn, 0) : fns.push(fn);
      };
    });
  });
  var spriteNodeId = '__SVG_SPRITE_NODE__';
  var spriteGlobalVarName = '__SVG_SPRITE__';
  var isSpriteExists = !!window[spriteGlobalVarName];

  // eslint-disable-next-line import/no-mutable-exports
  var sprite;
  if (isSpriteExists) {
    sprite = window[spriteGlobalVarName];
  } else {
    sprite = new BrowserSprite({
      attrs: {
        id: spriteNodeId,
        'aria-hidden': 'true'
      }
    });
    window[spriteGlobalVarName] = sprite;
  }
  var loadSprite = function loadSprite() {
    /**
     * Check for page already contains sprite node
     * If found - attach to and reuse it's content
     * If not - render and mount the new sprite
     */
    var existing = document.getElementById(spriteNodeId);
    if (existing) {
      sprite.attach(existing);
    } else {
      sprite.mount(document.body, true);
    }
  };
  if (document.body) {
    loadSprite();
  } else {
    ready$1(loadSprite);
  }
  var sprite$1 = sprite;
  return sprite$1;
});

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		__webpack_require__.p = "";
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry needs to be wrapped in an IIFE because it needs to be in strict mode.
(() => {
"use strict";

// UNUSED EXPORTS: default

;// ./src/js/Calc.js
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _slicedToArray(r, e) { return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(r) { if (Array.isArray(r)) return r; }
function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(r, a) { if (r) { if ("string" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }
function _iterableToArray(r) { if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r); }
function _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }
function _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }
function _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }
function _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", { writable: !1 }), e; }
function _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function"); }
function _defineProperty(e, r, t) { return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: !0, configurable: !0, writable: !0 }) : e[r] = t, e; }
function _toPropertyKey(t) { var i = _toPrimitive(t, "string"); return "symbol" == _typeof(i) ? i : i + ""; }
function _toPrimitive(t, r) { if ("object" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || "default"); if ("object" != _typeof(i)) return i; throw new TypeError("@@toPrimitive must return a primitive value."); } return ("string" === r ? String : Number)(t); }
var Calc = /*#__PURE__*/_createClass(function Calc(_ref) {
  var _this = this;
  var _ref$maxNumber = _ref.maxNumber,
    maxNumber = _ref$maxNumber === void 0 ? 10 : _ref$maxNumber,
    _ref$isSum = _ref.isSum,
    _isSum = _ref$isSum === void 0 ? true : _ref$isSum,
    _ref$isDiff = _ref.isDiff,
    _isDiff = _ref$isDiff === void 0 ? true : _ref$isDiff,
    _ref$formSelector = _ref.formSelector,
    formSelector = _ref$formSelector === void 0 ? '.js-form' : _ref$formSelector,
    _ref$fieldExpressionS = _ref.fieldExpressionSelector,
    fieldExpressionSelector = _ref$fieldExpressionS === void 0 ? '.js-form-expression' : _ref$fieldExpressionS,
    _ref$fieldResultSelec = _ref.fieldResultSelector,
    fieldResultSelector = _ref$fieldResultSelec === void 0 ? '.js-form-result' : _ref$fieldResultSelec,
    _ref$buttonNextSelect = _ref.buttonNextSelector,
    buttonNextSelector = _ref$buttonNextSelect === void 0 ? '.js-button-next' : _ref$buttonNextSelect,
    _ref$buttonResultSele = _ref.buttonResultSelector,
    buttonResultSelector = _ref$buttonResultSele === void 0 ? '.js-button-result' : _ref$buttonResultSele,
    _ref$checkboxSelector = _ref.checkboxSelector,
    checkboxSelector = _ref$checkboxSelector === void 0 ? '.js-form-input-checkbox' : _ref$checkboxSelector,
    _ref$numberSelector = _ref.numberSelector,
    numberSelector = _ref$numberSelector === void 0 ? '.js-form-input-number' : _ref$numberSelector;
  _classCallCheck(this, Calc);
  _defineProperty(this, "setResults", function () {
    _this.results = [];
    var _this$operationsStatu = _this.operationsStatus,
      isSum = _this$operationsStatu.sum,
      isDiff = _this$operationsStatu.diff;
    var numbers = Array.from({
      length: _this.maxNumber
    }, function (_, i) {
      return i + 1;
    });
    numbers.forEach(function (firstNumber) {
      numbers.forEach(function (secondNumber) {
        if (isSum && firstNumber + secondNumber <= _this.maxNumber) {
          _this.results.push("".concat(firstNumber, "+").concat(secondNumber));
        }
        if (isDiff && firstNumber - secondNumber >= 0) {
          _this.results.push("".concat(firstNumber, "-").concat(secondNumber));
        }
      });
    });
  });
  _defineProperty(this, "setDefaultInputsValue", function () {
    _toConsumableArray(_this.checkboxes).forEach(function (item) {
      item.checked = _this.operationsStatus[item.value];
    });
    _this.number.value = _this.maxNumber;
  });
  _defineProperty(this, "toggleCheckbox", function (event) {
    var _event$target = event.target,
      value = _event$target.value,
      type = _event$target.type,
      checked = _event$target.checked;
    if (type === 'checkbox') {
      _this.operationsStatus[value] = checked;
      _this.usedIndexes = [];
      _this.setResults();
    }
  });
  _defineProperty(this, "setInputValue", function (event) {
    var _event$target2 = event.target,
      value = _event$target2.value,
      type = _event$target2.type;
    if (type === 'number') {
      _this.maxNumber = value;
      _this.usedIndexes = [];
      _this.setResults();
    }
  });
  _defineProperty(this, "getRandomNumber", function () {
    var availableIndexes = _this.results.map(function (_, index) {
      return index;
    }).filter(function (index) {
      return !_this.usedIndexes.includes(index);
    });
    if (availableIndexes.length === 0) {
      _this.fieldExpression.textContent = 'Больше примеров нет';
      _this.fieldResult.textContent = '';
      _this.buttonResult.disabled = true;
      return null;
    }
    var randomIndex = Math.floor(Math.random() * availableIndexes.length);
    var chosenIndex = availableIndexes[randomIndex];
    _this.usedIndexes.push(chosenIndex);
    return chosenIndex;
  });
  _defineProperty(this, "createExpression", function () {
    var index = _this.getRandomNumber();
    if (index === null) return;
    var expression = _this.results[index];
    var _expression$split = expression.split(/([+\-])/),
      _expression$split2 = _slicedToArray(_expression$split, 3),
      firstNumber = _expression$split2[0],
      sign = _expression$split2[1],
      secondNumber = _expression$split2[2];
    _this.firstNumber = parseInt(firstNumber, 10);
    _this.sign = sign;
    _this.secondNumber = parseInt(secondNumber, 10);
    _this.fieldResult.textContent = '';
    _this.fieldExpression.textContent = "".concat(_this.firstNumber, " ").concat(_this.sign, " ").concat(_this.secondNumber, " = ");
  });
  _defineProperty(this, "viewResult", function () {
    _this.fieldResult.textContent = _this.operations[_this.sign](_this.firstNumber, _this.secondNumber);
  });
  _defineProperty(this, "setEventListeners", function () {
    _this.buttonNext.addEventListener('click', _this.createExpression);
    _this.buttonResult.addEventListener('click', _this.viewResult);
    _this.form.addEventListener('change', function (event) {
      _this.toggleCheckbox(event);
      _this.setInputValue(event);
    });
  });
  this.operationsStatus = {
    sum: _isSum,
    diff: _isDiff
  };
  this.maxNumber = maxNumber;
  this.form = document.querySelector(formSelector);
  this.fieldExpression = this.form.querySelector(fieldExpressionSelector);
  this.fieldResult = this.form.querySelector(fieldResultSelector);
  this.buttonNext = this.form.querySelector(buttonNextSelector);
  this.buttonResult = this.form.querySelector(buttonResultSelector);
  this.checkboxes = this.form.querySelectorAll(checkboxSelector);
  this.number = this.form.querySelector(numberSelector);
  this.results = [];
  this.usedIndexes = [];
  this.firstNumber = null;
  this.sign = null;
  this.secondNumber = null;
  this.operations = {
    '+': function _(a, b) {
      return a + b;
    },
    '-': function _(a, b) {
      return a - b;
    }
  };
  this.setDefaultInputsValue();
  this.setResults();
  this.setEventListeners();
});

;// ./src/index.js

var src_images = __webpack_require__(620);
var imagesMap = {};
src_images.keys().forEach(function (key) {
  imagesMap[key] = src_images(key);
});
/* harmony default export */ const src = ((/* unused pure expression or super */ null && (imagesMap)));
document.addEventListener('DOMContentLoaded', function () {
  var calc = new Calc({});
});
})();

/******/ })()
;
//# sourceMappingURL=index.js.map